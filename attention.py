"""
$ runner.py is running since (..) for (....) seconds
$ regular.py is currently searching for constructor of (.., ..) since (..) for (....) seconds
$ learner.py has seen (...) lines of text and found so far (..., ...., .....) to be your most significant interests
$ statistics.py updated at (...) and since (...) the workers have traveled (...)/(...) historical paths.







two numbers on number line can be brought closer together arbitrarily more than before.
line = np.linspace(0, N, D)
numbers = (x, y)

find where x and y are in the line?
a, b = line.index(x), line.index(y)

we can measure how far apart a and b are
d = abs(a - b)

can d be reduced more?
how could a or b be changed without changing x or y with them?
x and y are numbers that only have relative descriptions where any description would have to preserve the other associative description of those identities as numbers.
perhaps the distance is relative to the descriptor and other description are possible.
question now is to find functional description of the pairs which can cut the space between them by avoiding intermediate identities.










state ; which can have it, what changes, what shows that information?
machine : {
    is it on? : True,
    is it off? : False
    }
state of machine describe if it is on and whether it is off, or both false.

what causes the machine to stay off? or don't turn on?
can a catalyst be put into the environment?
which abstract catalyst codes for the machine catalyst?
for keeping the machine off and never otherwise the catalyst must stay capable at all times.

what if one catalyst decays? the knowledge must be copied onto a new catalyst.
that also needs an abstract catalyst which transfers the information.

if we describe the process of turning never on the machine, we have to include the machine at state 'is it on?' -> False
From state that isn't on, the other state 'is it off?' -> True must be ensured right after the first.
Then from the complete cycle of inspection, what prepares the next cycle?

If something causes state['is it on?'] to True, then the task of keeping the machine off is not successfull anymore.
But if something causes state['is it on?'] to be False, then it must also cause the other state attribute to remain True as long as it is a catalyst of the environment.

So a catalyst of that environment is that object which always puts the first state to False, whenever the machine could have s new cycle of power.
It is also that object whose absense would make the power cycle sometimes turn the machine on and perhaps never off if no catalyst is present for restricting the later.

Additionally, it is of those group of transformers whose presence keeps the group dedicated to the task replenished and prepared for any given cycle.

If the machine could only have one mode of operation and one encompassing description of its state, it cannot be transformed even via a catalyst, for it nothing changes.
If change is possible, then the machine being in different state is possible, and therefore a different description could be adapted, provided they describe the same object.
Permuting the possible attributes of the machine gives the complete set of possible states or descriptions that the states could take on.

A catalyst tuning its possible descriptions so that it never produces some particular state, would be programming the possible description that would be allowed when considering to environment.
Based on such a catalyst enabling the counterfactual information about the environment, we could take the knowledge to a different environment.
All those conditions requiring certain description of the machine to be manifest now could be asserted to have satisfied and it would be possible to consider the depedent object in question.

**Where do we find such a catalyst?**

For anything to be a catalyst, it must satisfy some criteria and all those not violating those properties could be considered as a catalyst.
For considering indirectly, we can prepare initialization tests for which if any naturally occuring object passes the threshold, it could be shown imperically that the counterfactual does not provably hold.












"""







# when a document is big and its contents are effecting current memory
# if the document is not shrunk before current task, the current memory will also produce mode document
# more document will map the old document with decaying memory of that old history
# decayed memory side chaining with active memory will magnify the intensity of each of the half-life evolutions

# how to solve the problem?
## find the most active impulse and its trace through subsequent impulse products
## while the tracing takes place, it should not start adding new impulses
## also for every discrete chunk in traced product, map all the paths from the forward direction towarda the backward direction
## see what origin point is predicted and eliminate the rest using counterfactual statements
### while traceback paths are available, zip each of the origins to the current position irreversibly
### also for every zip product, make sure the transformation is linear and does not cross any outside regions or scopes
### how to compress the long running texts in a meaningful shorter length equivalents?
#### the coherence in the document is not important in terms of standard language features
#### if there could be a transformation from those spaces to one of the constrained regions of spaces, it would be sufficient to have the nearest k neighbors of the current linearly transformed regions among the spaces which is a subset of all of them
#### if one of the k neighbors could recognize the information and one of the k subsequent neighbors can understand the current position, it implies that the current position is sufficient for informing the statistics of all the historical data
#### how do I select the k neighbors from left side and have them follow all of my next possible trajectories?
##### set up a formal method for some set of conditions that could be defined now but may not be satisfied yet.
##### for those that could be defined using expressions that conditionally depend on some other expression being evaluated, set the conditional dependence to be one of the possible position you might occupy regardless of any particular thing.
##### when a dependent situation is established, now establish some other regularity that could be achieved and some other knowledge presented to you would cause it to be achieved.
##### map each of the regular events that could be automatically interpolated from some signaling source into a regular expression type, since the regular conditions that satify depenency requirement for irregular functional, a number of those evaluations could be interpolated together to satisfy the other condition required by the function.

[what implicit information could inform about my regular explicit and discrete patterns]

- history of the browser
- sequential evolution of impulses
- terminal logs and its evolution
- notebooks and scripts

[what can gurantee the automatic execution of the processes and what happens if the computer is off]

- consider the routines used by os processes
- consider the design and media used to guide user
- consider the practice enforced for becoming an user
- consider the supports that assumes a basis for which solution is valid
